// Code generated by mockery v2.26.1. DO NOT EDIT.

package usecase

import (
	context "context"

	models "github.com/Puena/password-keeper/client/internal/models"
	mock "github.com/stretchr/testify/mock"
)

// MockStorageRepostiory is an autogenerated mock type for the StorageRepostiory type
type MockStorageRepostiory struct {
	mock.Mock
}

type MockStorageRepostiory_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStorageRepostiory) EXPECT() *MockStorageRepostiory_Expecter {
	return &MockStorageRepostiory_Expecter{mock: &_m.Mock}
}

// Delete provides a mock function with given fields: ctx, chestID, history
func (_m *MockStorageRepostiory) Delete(ctx context.Context, chestID string, history *models.History) error {
	ret := _m.Called(ctx, chestID, history)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *models.History) error); ok {
		r0 = rf(ctx, chestID, history)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStorageRepostiory_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockStorageRepostiory_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - chestID string
//   - history *models.History
func (_e *MockStorageRepostiory_Expecter) Delete(ctx interface{}, chestID interface{}, history interface{}) *MockStorageRepostiory_Delete_Call {
	return &MockStorageRepostiory_Delete_Call{Call: _e.mock.On("Delete", ctx, chestID, history)}
}

func (_c *MockStorageRepostiory_Delete_Call) Run(run func(ctx context.Context, chestID string, history *models.History)) *MockStorageRepostiory_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*models.History))
	})
	return _c
}

func (_c *MockStorageRepostiory_Delete_Call) Return(_a0 error) *MockStorageRepostiory_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStorageRepostiory_Delete_Call) RunAndReturn(run func(context.Context, string, *models.History) error) *MockStorageRepostiory_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Insert provides a mock function with given fields: ctx, chest, history
func (_m *MockStorageRepostiory) Insert(ctx context.Context, chest *models.Chest, history *models.History) error {
	ret := _m.Called(ctx, chest, history)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Chest, *models.History) error); ok {
		r0 = rf(ctx, chest, history)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStorageRepostiory_Insert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Insert'
type MockStorageRepostiory_Insert_Call struct {
	*mock.Call
}

// Insert is a helper method to define mock.On call
//   - ctx context.Context
//   - chest *models.Chest
//   - history *models.History
func (_e *MockStorageRepostiory_Expecter) Insert(ctx interface{}, chest interface{}, history interface{}) *MockStorageRepostiory_Insert_Call {
	return &MockStorageRepostiory_Insert_Call{Call: _e.mock.On("Insert", ctx, chest, history)}
}

func (_c *MockStorageRepostiory_Insert_Call) Run(run func(ctx context.Context, chest *models.Chest, history *models.History)) *MockStorageRepostiory_Insert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Chest), args[2].(*models.History))
	})
	return _c
}

func (_c *MockStorageRepostiory_Insert_Call) Return(_a0 error) *MockStorageRepostiory_Insert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStorageRepostiory_Insert_Call) RunAndReturn(run func(context.Context, *models.Chest, *models.History) error) *MockStorageRepostiory_Insert_Call {
	_c.Call.Return(run)
	return _c
}

// IsConfictError provides a mock function with given fields: err
func (_m *MockStorageRepostiory) IsConfictError(err error) bool {
	ret := _m.Called(err)

	var r0 bool
	if rf, ok := ret.Get(0).(func(error) bool); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockStorageRepostiory_IsConfictError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsConfictError'
type MockStorageRepostiory_IsConfictError_Call struct {
	*mock.Call
}

// IsConfictError is a helper method to define mock.On call
//   - err error
func (_e *MockStorageRepostiory_Expecter) IsConfictError(err interface{}) *MockStorageRepostiory_IsConfictError_Call {
	return &MockStorageRepostiory_IsConfictError_Call{Call: _e.mock.On("IsConfictError", err)}
}

func (_c *MockStorageRepostiory_IsConfictError_Call) Run(run func(err error)) *MockStorageRepostiory_IsConfictError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *MockStorageRepostiory_IsConfictError_Call) Return(_a0 bool) *MockStorageRepostiory_IsConfictError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStorageRepostiory_IsConfictError_Call) RunAndReturn(run func(error) bool) *MockStorageRepostiory_IsConfictError_Call {
	_c.Call.Return(run)
	return _c
}

// IsNotFoundError provides a mock function with given fields: err
func (_m *MockStorageRepostiory) IsNotFoundError(err error) bool {
	ret := _m.Called(err)

	var r0 bool
	if rf, ok := ret.Get(0).(func(error) bool); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockStorageRepostiory_IsNotFoundError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsNotFoundError'
type MockStorageRepostiory_IsNotFoundError_Call struct {
	*mock.Call
}

// IsNotFoundError is a helper method to define mock.On call
//   - err error
func (_e *MockStorageRepostiory_Expecter) IsNotFoundError(err interface{}) *MockStorageRepostiory_IsNotFoundError_Call {
	return &MockStorageRepostiory_IsNotFoundError_Call{Call: _e.mock.On("IsNotFoundError", err)}
}

func (_c *MockStorageRepostiory_IsNotFoundError_Call) Run(run func(err error)) *MockStorageRepostiory_IsNotFoundError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *MockStorageRepostiory_IsNotFoundError_Call) Return(_a0 bool) *MockStorageRepostiory_IsNotFoundError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStorageRepostiory_IsNotFoundError_Call) RunAndReturn(run func(error) bool) *MockStorageRepostiory_IsNotFoundError_Call {
	_c.Call.Return(run)
	return _c
}

// SelectChestAndHistoryByID provides a mock function with given fields: ctx, chestID
func (_m *MockStorageRepostiory) SelectChestAndHistoryByID(ctx context.Context, chestID string) (*models.Chest, []*models.History, error) {
	ret := _m.Called(ctx, chestID)

	var r0 *models.Chest
	var r1 []*models.History
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Chest, []*models.History, error)); ok {
		return rf(ctx, chestID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Chest); ok {
		r0 = rf(ctx, chestID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Chest)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) []*models.History); ok {
		r1 = rf(ctx, chestID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*models.History)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = rf(ctx, chestID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockStorageRepostiory_SelectChestAndHistoryByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectChestAndHistoryByID'
type MockStorageRepostiory_SelectChestAndHistoryByID_Call struct {
	*mock.Call
}

// SelectChestAndHistoryByID is a helper method to define mock.On call
//   - ctx context.Context
//   - chestID string
func (_e *MockStorageRepostiory_Expecter) SelectChestAndHistoryByID(ctx interface{}, chestID interface{}) *MockStorageRepostiory_SelectChestAndHistoryByID_Call {
	return &MockStorageRepostiory_SelectChestAndHistoryByID_Call{Call: _e.mock.On("SelectChestAndHistoryByID", ctx, chestID)}
}

func (_c *MockStorageRepostiory_SelectChestAndHistoryByID_Call) Run(run func(ctx context.Context, chestID string)) *MockStorageRepostiory_SelectChestAndHistoryByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStorageRepostiory_SelectChestAndHistoryByID_Call) Return(chest *models.Chest, history []*models.History, err error) *MockStorageRepostiory_SelectChestAndHistoryByID_Call {
	_c.Call.Return(chest, history, err)
	return _c
}

func (_c *MockStorageRepostiory_SelectChestAndHistoryByID_Call) RunAndReturn(run func(context.Context, string) (*models.Chest, []*models.History, error)) *MockStorageRepostiory_SelectChestAndHistoryByID_Call {
	_c.Call.Return(run)
	return _c
}

// SelectChestByName provides a mock function with given fields: ctx, name
func (_m *MockStorageRepostiory) SelectChestByName(ctx context.Context, name string) (*models.Chest, error) {
	ret := _m.Called(ctx, name)

	var r0 *models.Chest
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Chest, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Chest); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Chest)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStorageRepostiory_SelectChestByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectChestByName'
type MockStorageRepostiory_SelectChestByName_Call struct {
	*mock.Call
}

// SelectChestByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockStorageRepostiory_Expecter) SelectChestByName(ctx interface{}, name interface{}) *MockStorageRepostiory_SelectChestByName_Call {
	return &MockStorageRepostiory_SelectChestByName_Call{Call: _e.mock.On("SelectChestByName", ctx, name)}
}

func (_c *MockStorageRepostiory_SelectChestByName_Call) Run(run func(ctx context.Context, name string)) *MockStorageRepostiory_SelectChestByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStorageRepostiory_SelectChestByName_Call) Return(chest *models.Chest, err error) *MockStorageRepostiory_SelectChestByName_Call {
	_c.Call.Return(chest, err)
	return _c
}

func (_c *MockStorageRepostiory_SelectChestByName_Call) RunAndReturn(run func(context.Context, string) (*models.Chest, error)) *MockStorageRepostiory_SelectChestByName_Call {
	_c.Call.Return(run)
	return _c
}

// SelectIdNameTypeChests provides a mock function with given fields: ctx
func (_m *MockStorageRepostiory) SelectIdNameTypeChests(ctx context.Context) ([]*models.Chest, error) {
	ret := _m.Called(ctx)

	var r0 []*models.Chest
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*models.Chest, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*models.Chest); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.Chest)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStorageRepostiory_SelectIdNameTypeChests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectIdNameTypeChests'
type MockStorageRepostiory_SelectIdNameTypeChests_Call struct {
	*mock.Call
}

// SelectIdNameTypeChests is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStorageRepostiory_Expecter) SelectIdNameTypeChests(ctx interface{}) *MockStorageRepostiory_SelectIdNameTypeChests_Call {
	return &MockStorageRepostiory_SelectIdNameTypeChests_Call{Call: _e.mock.On("SelectIdNameTypeChests", ctx)}
}

func (_c *MockStorageRepostiory_SelectIdNameTypeChests_Call) Run(run func(ctx context.Context)) *MockStorageRepostiory_SelectIdNameTypeChests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStorageRepostiory_SelectIdNameTypeChests_Call) Return(chests []*models.Chest, err error) *MockStorageRepostiory_SelectIdNameTypeChests_Call {
	_c.Call.Return(chests, err)
	return _c
}

func (_c *MockStorageRepostiory_SelectIdNameTypeChests_Call) RunAndReturn(run func(context.Context) ([]*models.Chest, error)) *MockStorageRepostiory_SelectIdNameTypeChests_Call {
	_c.Call.Return(run)
	return _c
}

// SelectLastHistoryEventForAllChests provides a mock function with given fields: ctx
func (_m *MockStorageRepostiory) SelectLastHistoryEventForAllChests(ctx context.Context) ([]*models.History, error) {
	ret := _m.Called(ctx)

	var r0 []*models.History
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*models.History, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*models.History); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.History)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStorageRepostiory_SelectLastHistoryEventForAllChests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectLastHistoryEventForAllChests'
type MockStorageRepostiory_SelectLastHistoryEventForAllChests_Call struct {
	*mock.Call
}

// SelectLastHistoryEventForAllChests is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStorageRepostiory_Expecter) SelectLastHistoryEventForAllChests(ctx interface{}) *MockStorageRepostiory_SelectLastHistoryEventForAllChests_Call {
	return &MockStorageRepostiory_SelectLastHistoryEventForAllChests_Call{Call: _e.mock.On("SelectLastHistoryEventForAllChests", ctx)}
}

func (_c *MockStorageRepostiory_SelectLastHistoryEventForAllChests_Call) Run(run func(ctx context.Context)) *MockStorageRepostiory_SelectLastHistoryEventForAllChests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStorageRepostiory_SelectLastHistoryEventForAllChests_Call) Return(history []*models.History, err error) *MockStorageRepostiory_SelectLastHistoryEventForAllChests_Call {
	_c.Call.Return(history, err)
	return _c
}

func (_c *MockStorageRepostiory_SelectLastHistoryEventForAllChests_Call) RunAndReturn(run func(context.Context) ([]*models.History, error)) *MockStorageRepostiory_SelectLastHistoryEventForAllChests_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, chest, history
func (_m *MockStorageRepostiory) Update(ctx context.Context, chest *models.Chest, history *models.History) error {
	ret := _m.Called(ctx, chest, history)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Chest, *models.History) error); ok {
		r0 = rf(ctx, chest, history)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStorageRepostiory_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockStorageRepostiory_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - chest *models.Chest
//   - history *models.History
func (_e *MockStorageRepostiory_Expecter) Update(ctx interface{}, chest interface{}, history interface{}) *MockStorageRepostiory_Update_Call {
	return &MockStorageRepostiory_Update_Call{Call: _e.mock.On("Update", ctx, chest, history)}
}

func (_c *MockStorageRepostiory_Update_Call) Run(run func(ctx context.Context, chest *models.Chest, history *models.History)) *MockStorageRepostiory_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Chest), args[2].(*models.History))
	})
	return _c
}

func (_c *MockStorageRepostiory_Update_Call) Return(_a0 error) *MockStorageRepostiory_Update_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStorageRepostiory_Update_Call) RunAndReturn(run func(context.Context, *models.Chest, *models.History) error) *MockStorageRepostiory_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateHistorySyncData provides a mock function with given fields: ctx, history
func (_m *MockStorageRepostiory) UpdateHistorySyncData(ctx context.Context, history *models.History) error {
	ret := _m.Called(ctx, history)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.History) error); ok {
		r0 = rf(ctx, history)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStorageRepostiory_UpdateHistorySyncData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateHistorySyncData'
type MockStorageRepostiory_UpdateHistorySyncData_Call struct {
	*mock.Call
}

// UpdateHistorySyncData is a helper method to define mock.On call
//   - ctx context.Context
//   - history *models.History
func (_e *MockStorageRepostiory_Expecter) UpdateHistorySyncData(ctx interface{}, history interface{}) *MockStorageRepostiory_UpdateHistorySyncData_Call {
	return &MockStorageRepostiory_UpdateHistorySyncData_Call{Call: _e.mock.On("UpdateHistorySyncData", ctx, history)}
}

func (_c *MockStorageRepostiory_UpdateHistorySyncData_Call) Run(run func(ctx context.Context, history *models.History)) *MockStorageRepostiory_UpdateHistorySyncData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.History))
	})
	return _c
}

func (_c *MockStorageRepostiory_UpdateHistorySyncData_Call) Return(_a0 error) *MockStorageRepostiory_UpdateHistorySyncData_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStorageRepostiory_UpdateHistorySyncData_Call) RunAndReturn(run func(context.Context, *models.History) error) *MockStorageRepostiory_UpdateHistorySyncData_Call {
	_c.Call.Return(run)
	return _c
}

// Upsert provides a mock function with given fields: ctx, chest, history
func (_m *MockStorageRepostiory) Upsert(ctx context.Context, chest *models.Chest, history *models.History) error {
	ret := _m.Called(ctx, chest, history)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Chest, *models.History) error); ok {
		r0 = rf(ctx, chest, history)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStorageRepostiory_Upsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upsert'
type MockStorageRepostiory_Upsert_Call struct {
	*mock.Call
}

// Upsert is a helper method to define mock.On call
//   - ctx context.Context
//   - chest *models.Chest
//   - history *models.History
func (_e *MockStorageRepostiory_Expecter) Upsert(ctx interface{}, chest interface{}, history interface{}) *MockStorageRepostiory_Upsert_Call {
	return &MockStorageRepostiory_Upsert_Call{Call: _e.mock.On("Upsert", ctx, chest, history)}
}

func (_c *MockStorageRepostiory_Upsert_Call) Run(run func(ctx context.Context, chest *models.Chest, history *models.History)) *MockStorageRepostiory_Upsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Chest), args[2].(*models.History))
	})
	return _c
}

func (_c *MockStorageRepostiory_Upsert_Call) Return(_a0 error) *MockStorageRepostiory_Upsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStorageRepostiory_Upsert_Call) RunAndReturn(run func(context.Context, *models.Chest, *models.History) error) *MockStorageRepostiory_Upsert_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewMockStorageRepostiory interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockStorageRepostiory creates a new instance of MockStorageRepostiory. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockStorageRepostiory(t mockConstructorTestingTNewMockStorageRepostiory) *MockStorageRepostiory {
	mock := &MockStorageRepostiory{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
