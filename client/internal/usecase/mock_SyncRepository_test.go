// Code generated by mockery v2.26.1. DO NOT EDIT.

package usecase

import (
	context "context"

	models "github.com/Puena/password-keeper/client/internal/models"
	mock "github.com/stretchr/testify/mock"
)

// MockSyncRepository is an autogenerated mock type for the SyncRepository type
type MockSyncRepository struct {
	mock.Mock
}

type MockSyncRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSyncRepository) EXPECT() *MockSyncRepository_Expecter {
	return &MockSyncRepository_Expecter{mock: &_m.Mock}
}

// AddChest provides a mock function with given fields: ctx, chest, history
func (_m *MockSyncRepository) AddChest(ctx context.Context, chest *models.Chest, history *models.History) (*models.History, error) {
	ret := _m.Called(ctx, chest, history)

	var r0 *models.History
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Chest, *models.History) (*models.History, error)); ok {
		return rf(ctx, chest, history)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Chest, *models.History) *models.History); ok {
		r0 = rf(ctx, chest, history)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.History)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Chest, *models.History) error); ok {
		r1 = rf(ctx, chest, history)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSyncRepository_AddChest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddChest'
type MockSyncRepository_AddChest_Call struct {
	*mock.Call
}

// AddChest is a helper method to define mock.On call
//   - ctx context.Context
//   - chest *models.Chest
//   - history *models.History
func (_e *MockSyncRepository_Expecter) AddChest(ctx interface{}, chest interface{}, history interface{}) *MockSyncRepository_AddChest_Call {
	return &MockSyncRepository_AddChest_Call{Call: _e.mock.On("AddChest", ctx, chest, history)}
}

func (_c *MockSyncRepository_AddChest_Call) Run(run func(ctx context.Context, chest *models.Chest, history *models.History)) *MockSyncRepository_AddChest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Chest), args[2].(*models.History))
	})
	return _c
}

func (_c *MockSyncRepository_AddChest_Call) Return(_a0 *models.History, _a1 error) *MockSyncRepository_AddChest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSyncRepository_AddChest_Call) RunAndReturn(run func(context.Context, *models.Chest, *models.History) (*models.History, error)) *MockSyncRepository_AddChest_Call {
	_c.Call.Return(run)
	return _c
}

// Authentification provides a mock function with given fields: ctx, data
func (_m *MockSyncRepository) Authentification(ctx context.Context, data *models.AuthData) (string, error) {
	ret := _m.Called(ctx, data)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.AuthData) (string, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.AuthData) string); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.AuthData) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSyncRepository_Authentification_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Authentification'
type MockSyncRepository_Authentification_Call struct {
	*mock.Call
}

// Authentification is a helper method to define mock.On call
//   - ctx context.Context
//   - data *models.AuthData
func (_e *MockSyncRepository_Expecter) Authentification(ctx interface{}, data interface{}) *MockSyncRepository_Authentification_Call {
	return &MockSyncRepository_Authentification_Call{Call: _e.mock.On("Authentification", ctx, data)}
}

func (_c *MockSyncRepository_Authentification_Call) Run(run func(ctx context.Context, data *models.AuthData)) *MockSyncRepository_Authentification_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.AuthData))
	})
	return _c
}

func (_c *MockSyncRepository_Authentification_Call) Return(_a0 string, _a1 error) *MockSyncRepository_Authentification_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSyncRepository_Authentification_Call) RunAndReturn(run func(context.Context, *models.AuthData) (string, error)) *MockSyncRepository_Authentification_Call {
	_c.Call.Return(run)
	return _c
}

// BadUserDataError provides a mock function with given fields: err
func (_m *MockSyncRepository) BadUserDataError(err error) error {
	ret := _m.Called(err)

	var r0 error
	if rf, ok := ret.Get(0).(func(error) error); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSyncRepository_BadUserDataError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BadUserDataError'
type MockSyncRepository_BadUserDataError_Call struct {
	*mock.Call
}

// BadUserDataError is a helper method to define mock.On call
//   - err error
func (_e *MockSyncRepository_Expecter) BadUserDataError(err interface{}) *MockSyncRepository_BadUserDataError_Call {
	return &MockSyncRepository_BadUserDataError_Call{Call: _e.mock.On("BadUserDataError", err)}
}

func (_c *MockSyncRepository_BadUserDataError_Call) Run(run func(err error)) *MockSyncRepository_BadUserDataError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *MockSyncRepository_BadUserDataError_Call) Return(_a0 error) *MockSyncRepository_BadUserDataError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSyncRepository_BadUserDataError_Call) RunAndReturn(run func(error) error) *MockSyncRepository_BadUserDataError_Call {
	_c.Call.Return(run)
	return _c
}

// CloseConnection provides a mock function with given fields:
func (_m *MockSyncRepository) CloseConnection() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSyncRepository_CloseConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CloseConnection'
type MockSyncRepository_CloseConnection_Call struct {
	*mock.Call
}

// CloseConnection is a helper method to define mock.On call
func (_e *MockSyncRepository_Expecter) CloseConnection() *MockSyncRepository_CloseConnection_Call {
	return &MockSyncRepository_CloseConnection_Call{Call: _e.mock.On("CloseConnection")}
}

func (_c *MockSyncRepository_CloseConnection_Call) Run(run func()) *MockSyncRepository_CloseConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSyncRepository_CloseConnection_Call) Return(_a0 error) *MockSyncRepository_CloseConnection_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSyncRepository_CloseConnection_Call) RunAndReturn(run func() error) *MockSyncRepository_CloseConnection_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteChest provides a mock function with given fields: ctx, history
func (_m *MockSyncRepository) DeleteChest(ctx context.Context, history *models.History) (*models.History, error) {
	ret := _m.Called(ctx, history)

	var r0 *models.History
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.History) (*models.History, error)); ok {
		return rf(ctx, history)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.History) *models.History); ok {
		r0 = rf(ctx, history)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.History)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.History) error); ok {
		r1 = rf(ctx, history)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSyncRepository_DeleteChest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteChest'
type MockSyncRepository_DeleteChest_Call struct {
	*mock.Call
}

// DeleteChest is a helper method to define mock.On call
//   - ctx context.Context
//   - history *models.History
func (_e *MockSyncRepository_Expecter) DeleteChest(ctx interface{}, history interface{}) *MockSyncRepository_DeleteChest_Call {
	return &MockSyncRepository_DeleteChest_Call{Call: _e.mock.On("DeleteChest", ctx, history)}
}

func (_c *MockSyncRepository_DeleteChest_Call) Run(run func(ctx context.Context, history *models.History)) *MockSyncRepository_DeleteChest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.History))
	})
	return _c
}

func (_c *MockSyncRepository_DeleteChest_Call) Return(_a0 *models.History, _a1 error) *MockSyncRepository_DeleteChest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSyncRepository_DeleteChest_Call) RunAndReturn(run func(context.Context, *models.History) (*models.History, error)) *MockSyncRepository_DeleteChest_Call {
	_c.Call.Return(run)
	return _c
}

// EstablishConnection provides a mock function with given fields: authToken
func (_m *MockSyncRepository) EstablishConnection(authToken string) error {
	ret := _m.Called(authToken)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(authToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSyncRepository_EstablishConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EstablishConnection'
type MockSyncRepository_EstablishConnection_Call struct {
	*mock.Call
}

// EstablishConnection is a helper method to define mock.On call
//   - authToken string
func (_e *MockSyncRepository_Expecter) EstablishConnection(authToken interface{}) *MockSyncRepository_EstablishConnection_Call {
	return &MockSyncRepository_EstablishConnection_Call{Call: _e.mock.On("EstablishConnection", authToken)}
}

func (_c *MockSyncRepository_EstablishConnection_Call) Run(run func(authToken string)) *MockSyncRepository_EstablishConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockSyncRepository_EstablishConnection_Call) Return(_a0 error) *MockSyncRepository_EstablishConnection_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSyncRepository_EstablishConnection_Call) RunAndReturn(run func(string) error) *MockSyncRepository_EstablishConnection_Call {
	_c.Call.Return(run)
	return _c
}

// GetChestByID provides a mock function with given fields: ctx, chestID
func (_m *MockSyncRepository) GetChestByID(ctx context.Context, chestID string) (*models.Chest, *models.History, error) {
	ret := _m.Called(ctx, chestID)

	var r0 *models.Chest
	var r1 *models.History
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Chest, *models.History, error)); ok {
		return rf(ctx, chestID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Chest); ok {
		r0 = rf(ctx, chestID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Chest)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) *models.History); ok {
		r1 = rf(ctx, chestID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*models.History)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = rf(ctx, chestID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockSyncRepository_GetChestByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChestByID'
type MockSyncRepository_GetChestByID_Call struct {
	*mock.Call
}

// GetChestByID is a helper method to define mock.On call
//   - ctx context.Context
//   - chestID string
func (_e *MockSyncRepository_Expecter) GetChestByID(ctx interface{}, chestID interface{}) *MockSyncRepository_GetChestByID_Call {
	return &MockSyncRepository_GetChestByID_Call{Call: _e.mock.On("GetChestByID", ctx, chestID)}
}

func (_c *MockSyncRepository_GetChestByID_Call) Run(run func(ctx context.Context, chestID string)) *MockSyncRepository_GetChestByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockSyncRepository_GetChestByID_Call) Return(_a0 *models.Chest, _a1 *models.History, _a2 error) *MockSyncRepository_GetChestByID_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockSyncRepository_GetChestByID_Call) RunAndReturn(run func(context.Context, string) (*models.Chest, *models.History, error)) *MockSyncRepository_GetChestByID_Call {
	_c.Call.Return(run)
	return _c
}

// IsAuthentificationError provides a mock function with given fields: err
func (_m *MockSyncRepository) IsAuthentificationError(err error) bool {
	ret := _m.Called(err)

	var r0 bool
	if rf, ok := ret.Get(0).(func(error) bool); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockSyncRepository_IsAuthentificationError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsAuthentificationError'
type MockSyncRepository_IsAuthentificationError_Call struct {
	*mock.Call
}

// IsAuthentificationError is a helper method to define mock.On call
//   - err error
func (_e *MockSyncRepository_Expecter) IsAuthentificationError(err interface{}) *MockSyncRepository_IsAuthentificationError_Call {
	return &MockSyncRepository_IsAuthentificationError_Call{Call: _e.mock.On("IsAuthentificationError", err)}
}

func (_c *MockSyncRepository_IsAuthentificationError_Call) Run(run func(err error)) *MockSyncRepository_IsAuthentificationError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *MockSyncRepository_IsAuthentificationError_Call) Return(_a0 bool) *MockSyncRepository_IsAuthentificationError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSyncRepository_IsAuthentificationError_Call) RunAndReturn(run func(error) bool) *MockSyncRepository_IsAuthentificationError_Call {
	_c.Call.Return(run)
	return _c
}

// IsConnectionError provides a mock function with given fields: err
func (_m *MockSyncRepository) IsConnectionError(err error) bool {
	ret := _m.Called(err)

	var r0 bool
	if rf, ok := ret.Get(0).(func(error) bool); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockSyncRepository_IsConnectionError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsConnectionError'
type MockSyncRepository_IsConnectionError_Call struct {
	*mock.Call
}

// IsConnectionError is a helper method to define mock.On call
//   - err error
func (_e *MockSyncRepository_Expecter) IsConnectionError(err interface{}) *MockSyncRepository_IsConnectionError_Call {
	return &MockSyncRepository_IsConnectionError_Call{Call: _e.mock.On("IsConnectionError", err)}
}

func (_c *MockSyncRepository_IsConnectionError_Call) Run(run func(err error)) *MockSyncRepository_IsConnectionError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *MockSyncRepository_IsConnectionError_Call) Return(_a0 bool) *MockSyncRepository_IsConnectionError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSyncRepository_IsConnectionError_Call) RunAndReturn(run func(error) bool) *MockSyncRepository_IsConnectionError_Call {
	_c.Call.Return(run)
	return _c
}

// IsDataAlreadyExistsError provides a mock function with given fields: err
func (_m *MockSyncRepository) IsDataAlreadyExistsError(err error) bool {
	ret := _m.Called(err)

	var r0 bool
	if rf, ok := ret.Get(0).(func(error) bool); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockSyncRepository_IsDataAlreadyExistsError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsDataAlreadyExistsError'
type MockSyncRepository_IsDataAlreadyExistsError_Call struct {
	*mock.Call
}

// IsDataAlreadyExistsError is a helper method to define mock.On call
//   - err error
func (_e *MockSyncRepository_Expecter) IsDataAlreadyExistsError(err interface{}) *MockSyncRepository_IsDataAlreadyExistsError_Call {
	return &MockSyncRepository_IsDataAlreadyExistsError_Call{Call: _e.mock.On("IsDataAlreadyExistsError", err)}
}

func (_c *MockSyncRepository_IsDataAlreadyExistsError_Call) Run(run func(err error)) *MockSyncRepository_IsDataAlreadyExistsError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *MockSyncRepository_IsDataAlreadyExistsError_Call) Return(_a0 bool) *MockSyncRepository_IsDataAlreadyExistsError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSyncRepository_IsDataAlreadyExistsError_Call) RunAndReturn(run func(error) bool) *MockSyncRepository_IsDataAlreadyExistsError_Call {
	_c.Call.Return(run)
	return _c
}

// IsNotFoundError provides a mock function with given fields: err
func (_m *MockSyncRepository) IsNotFoundError(err error) bool {
	ret := _m.Called(err)

	var r0 bool
	if rf, ok := ret.Get(0).(func(error) bool); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockSyncRepository_IsNotFoundError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsNotFoundError'
type MockSyncRepository_IsNotFoundError_Call struct {
	*mock.Call
}

// IsNotFoundError is a helper method to define mock.On call
//   - err error
func (_e *MockSyncRepository_Expecter) IsNotFoundError(err interface{}) *MockSyncRepository_IsNotFoundError_Call {
	return &MockSyncRepository_IsNotFoundError_Call{Call: _e.mock.On("IsNotFoundError", err)}
}

func (_c *MockSyncRepository_IsNotFoundError_Call) Run(run func(err error)) *MockSyncRepository_IsNotFoundError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(error))
	})
	return _c
}

func (_c *MockSyncRepository_IsNotFoundError_Call) Return(_a0 bool) *MockSyncRepository_IsNotFoundError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSyncRepository_IsNotFoundError_Call) RunAndReturn(run func(error) bool) *MockSyncRepository_IsNotFoundError_Call {
	_c.Call.Return(run)
	return _c
}

// Registration provides a mock function with given fields: ctx, data
func (_m *MockSyncRepository) Registration(ctx context.Context, data *models.AuthData) (string, error) {
	ret := _m.Called(ctx, data)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.AuthData) (string, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.AuthData) string); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.AuthData) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSyncRepository_Registration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Registration'
type MockSyncRepository_Registration_Call struct {
	*mock.Call
}

// Registration is a helper method to define mock.On call
//   - ctx context.Context
//   - data *models.AuthData
func (_e *MockSyncRepository_Expecter) Registration(ctx interface{}, data interface{}) *MockSyncRepository_Registration_Call {
	return &MockSyncRepository_Registration_Call{Call: _e.mock.On("Registration", ctx, data)}
}

func (_c *MockSyncRepository_Registration_Call) Run(run func(ctx context.Context, data *models.AuthData)) *MockSyncRepository_Registration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.AuthData))
	})
	return _c
}

func (_c *MockSyncRepository_Registration_Call) Return(_a0 string, _a1 error) *MockSyncRepository_Registration_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSyncRepository_Registration_Call) RunAndReturn(run func(context.Context, *models.AuthData) (string, error)) *MockSyncRepository_Registration_Call {
	_c.Call.Return(run)
	return _c
}

// Sync provides a mock function with given fields: ctx, history
func (_m *MockSyncRepository) Sync(ctx context.Context, history []*models.History) ([]*models.History, error) {
	ret := _m.Called(ctx, history)

	var r0 []*models.History
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*models.History) ([]*models.History, error)); ok {
		return rf(ctx, history)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*models.History) []*models.History); ok {
		r0 = rf(ctx, history)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.History)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*models.History) error); ok {
		r1 = rf(ctx, history)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSyncRepository_Sync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sync'
type MockSyncRepository_Sync_Call struct {
	*mock.Call
}

// Sync is a helper method to define mock.On call
//   - ctx context.Context
//   - history []*models.History
func (_e *MockSyncRepository_Expecter) Sync(ctx interface{}, history interface{}) *MockSyncRepository_Sync_Call {
	return &MockSyncRepository_Sync_Call{Call: _e.mock.On("Sync", ctx, history)}
}

func (_c *MockSyncRepository_Sync_Call) Run(run func(ctx context.Context, history []*models.History)) *MockSyncRepository_Sync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*models.History))
	})
	return _c
}

func (_c *MockSyncRepository_Sync_Call) Return(_a0 []*models.History, _a1 error) *MockSyncRepository_Sync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSyncRepository_Sync_Call) RunAndReturn(run func(context.Context, []*models.History) ([]*models.History, error)) *MockSyncRepository_Sync_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateChest provides a mock function with given fields: ctx, chest, history
func (_m *MockSyncRepository) UpdateChest(ctx context.Context, chest *models.Chest, history *models.History) (*models.History, error) {
	ret := _m.Called(ctx, chest, history)

	var r0 *models.History
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.Chest, *models.History) (*models.History, error)); ok {
		return rf(ctx, chest, history)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.Chest, *models.History) *models.History); ok {
		r0 = rf(ctx, chest, history)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.History)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.Chest, *models.History) error); ok {
		r1 = rf(ctx, chest, history)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSyncRepository_UpdateChest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateChest'
type MockSyncRepository_UpdateChest_Call struct {
	*mock.Call
}

// UpdateChest is a helper method to define mock.On call
//   - ctx context.Context
//   - chest *models.Chest
//   - history *models.History
func (_e *MockSyncRepository_Expecter) UpdateChest(ctx interface{}, chest interface{}, history interface{}) *MockSyncRepository_UpdateChest_Call {
	return &MockSyncRepository_UpdateChest_Call{Call: _e.mock.On("UpdateChest", ctx, chest, history)}
}

func (_c *MockSyncRepository_UpdateChest_Call) Run(run func(ctx context.Context, chest *models.Chest, history *models.History)) *MockSyncRepository_UpdateChest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.Chest), args[2].(*models.History))
	})
	return _c
}

func (_c *MockSyncRepository_UpdateChest_Call) Return(_a0 *models.History, _a1 error) *MockSyncRepository_UpdateChest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSyncRepository_UpdateChest_Call) RunAndReturn(run func(context.Context, *models.Chest, *models.History) (*models.History, error)) *MockSyncRepository_UpdateChest_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewMockSyncRepository interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockSyncRepository creates a new instance of MockSyncRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockSyncRepository(t mockConstructorTestingTNewMockSyncRepository) *MockSyncRepository {
	mock := &MockSyncRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
