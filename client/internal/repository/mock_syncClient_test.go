// Code generated by mockery v2.26.1. DO NOT EDIT.

package repository

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	proto "github.com/Puena/password-keeper/proto"
)

// mockSyncClient is an autogenerated mock type for the syncClient type
type mockSyncClient struct {
	mock.Mock
}

type mockSyncClient_Expecter struct {
	mock *mock.Mock
}

func (_m *mockSyncClient) EXPECT() *mockSyncClient_Expecter {
	return &mockSyncClient_Expecter{mock: &_m.Mock}
}

// AddChest provides a mock function with given fields: ctx, in, opts
func (_m *mockSyncClient) AddChest(ctx context.Context, in *proto.ChestRequest, opts ...grpc.CallOption) (*proto.HistoryResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *proto.HistoryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *proto.ChestRequest, ...grpc.CallOption) (*proto.HistoryResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *proto.ChestRequest, ...grpc.CallOption) *proto.HistoryResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*proto.HistoryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *proto.ChestRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockSyncClient_AddChest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddChest'
type mockSyncClient_AddChest_Call struct {
	*mock.Call
}

// AddChest is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.ChestRequest
//   - opts ...grpc.CallOption
func (_e *mockSyncClient_Expecter) AddChest(ctx interface{}, in interface{}, opts ...interface{}) *mockSyncClient_AddChest_Call {
	return &mockSyncClient_AddChest_Call{Call: _e.mock.On("AddChest",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *mockSyncClient_AddChest_Call) Run(run func(ctx context.Context, in *proto.ChestRequest, opts ...grpc.CallOption)) *mockSyncClient_AddChest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*proto.ChestRequest), variadicArgs...)
	})
	return _c
}

func (_c *mockSyncClient_AddChest_Call) Return(_a0 *proto.HistoryResponse, _a1 error) *mockSyncClient_AddChest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockSyncClient_AddChest_Call) RunAndReturn(run func(context.Context, *proto.ChestRequest, ...grpc.CallOption) (*proto.HistoryResponse, error)) *mockSyncClient_AddChest_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteChest provides a mock function with given fields: ctx, in, opts
func (_m *mockSyncClient) DeleteChest(ctx context.Context, in *proto.DeleteChestRequest, opts ...grpc.CallOption) (*proto.HistoryResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *proto.HistoryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteChestRequest, ...grpc.CallOption) (*proto.HistoryResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *proto.DeleteChestRequest, ...grpc.CallOption) *proto.HistoryResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*proto.HistoryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *proto.DeleteChestRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockSyncClient_DeleteChest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteChest'
type mockSyncClient_DeleteChest_Call struct {
	*mock.Call
}

// DeleteChest is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.DeleteChestRequest
//   - opts ...grpc.CallOption
func (_e *mockSyncClient_Expecter) DeleteChest(ctx interface{}, in interface{}, opts ...interface{}) *mockSyncClient_DeleteChest_Call {
	return &mockSyncClient_DeleteChest_Call{Call: _e.mock.On("DeleteChest",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *mockSyncClient_DeleteChest_Call) Run(run func(ctx context.Context, in *proto.DeleteChestRequest, opts ...grpc.CallOption)) *mockSyncClient_DeleteChest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*proto.DeleteChestRequest), variadicArgs...)
	})
	return _c
}

func (_c *mockSyncClient_DeleteChest_Call) Return(_a0 *proto.HistoryResponse, _a1 error) *mockSyncClient_DeleteChest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockSyncClient_DeleteChest_Call) RunAndReturn(run func(context.Context, *proto.DeleteChestRequest, ...grpc.CallOption) (*proto.HistoryResponse, error)) *mockSyncClient_DeleteChest_Call {
	_c.Call.Return(run)
	return _c
}

// GetChestByID provides a mock function with given fields: ctx, in, opts
func (_m *mockSyncClient) GetChestByID(ctx context.Context, in *proto.ChestIDRequest, opts ...grpc.CallOption) (*proto.ChestResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *proto.ChestResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *proto.ChestIDRequest, ...grpc.CallOption) (*proto.ChestResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *proto.ChestIDRequest, ...grpc.CallOption) *proto.ChestResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*proto.ChestResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *proto.ChestIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockSyncClient_GetChestByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChestByID'
type mockSyncClient_GetChestByID_Call struct {
	*mock.Call
}

// GetChestByID is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.ChestIDRequest
//   - opts ...grpc.CallOption
func (_e *mockSyncClient_Expecter) GetChestByID(ctx interface{}, in interface{}, opts ...interface{}) *mockSyncClient_GetChestByID_Call {
	return &mockSyncClient_GetChestByID_Call{Call: _e.mock.On("GetChestByID",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *mockSyncClient_GetChestByID_Call) Run(run func(ctx context.Context, in *proto.ChestIDRequest, opts ...grpc.CallOption)) *mockSyncClient_GetChestByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*proto.ChestIDRequest), variadicArgs...)
	})
	return _c
}

func (_c *mockSyncClient_GetChestByID_Call) Return(_a0 *proto.ChestResponse, _a1 error) *mockSyncClient_GetChestByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockSyncClient_GetChestByID_Call) RunAndReturn(run func(context.Context, *proto.ChestIDRequest, ...grpc.CallOption) (*proto.ChestResponse, error)) *mockSyncClient_GetChestByID_Call {
	_c.Call.Return(run)
	return _c
}

// SignIn provides a mock function with given fields: ctx, in, opts
func (_m *mockSyncClient) SignIn(ctx context.Context, in *proto.AuthDataRequest, opts ...grpc.CallOption) (*proto.AuthTokenResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *proto.AuthTokenResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *proto.AuthDataRequest, ...grpc.CallOption) (*proto.AuthTokenResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *proto.AuthDataRequest, ...grpc.CallOption) *proto.AuthTokenResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*proto.AuthTokenResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *proto.AuthDataRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockSyncClient_SignIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignIn'
type mockSyncClient_SignIn_Call struct {
	*mock.Call
}

// SignIn is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.AuthDataRequest
//   - opts ...grpc.CallOption
func (_e *mockSyncClient_Expecter) SignIn(ctx interface{}, in interface{}, opts ...interface{}) *mockSyncClient_SignIn_Call {
	return &mockSyncClient_SignIn_Call{Call: _e.mock.On("SignIn",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *mockSyncClient_SignIn_Call) Run(run func(ctx context.Context, in *proto.AuthDataRequest, opts ...grpc.CallOption)) *mockSyncClient_SignIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*proto.AuthDataRequest), variadicArgs...)
	})
	return _c
}

func (_c *mockSyncClient_SignIn_Call) Return(_a0 *proto.AuthTokenResponse, _a1 error) *mockSyncClient_SignIn_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockSyncClient_SignIn_Call) RunAndReturn(run func(context.Context, *proto.AuthDataRequest, ...grpc.CallOption) (*proto.AuthTokenResponse, error)) *mockSyncClient_SignIn_Call {
	_c.Call.Return(run)
	return _c
}

// SignUp provides a mock function with given fields: ctx, in, opts
func (_m *mockSyncClient) SignUp(ctx context.Context, in *proto.AuthDataRequest, opts ...grpc.CallOption) (*proto.AuthTokenResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *proto.AuthTokenResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *proto.AuthDataRequest, ...grpc.CallOption) (*proto.AuthTokenResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *proto.AuthDataRequest, ...grpc.CallOption) *proto.AuthTokenResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*proto.AuthTokenResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *proto.AuthDataRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockSyncClient_SignUp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignUp'
type mockSyncClient_SignUp_Call struct {
	*mock.Call
}

// SignUp is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.AuthDataRequest
//   - opts ...grpc.CallOption
func (_e *mockSyncClient_Expecter) SignUp(ctx interface{}, in interface{}, opts ...interface{}) *mockSyncClient_SignUp_Call {
	return &mockSyncClient_SignUp_Call{Call: _e.mock.On("SignUp",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *mockSyncClient_SignUp_Call) Run(run func(ctx context.Context, in *proto.AuthDataRequest, opts ...grpc.CallOption)) *mockSyncClient_SignUp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*proto.AuthDataRequest), variadicArgs...)
	})
	return _c
}

func (_c *mockSyncClient_SignUp_Call) Return(_a0 *proto.AuthTokenResponse, _a1 error) *mockSyncClient_SignUp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockSyncClient_SignUp_Call) RunAndReturn(run func(context.Context, *proto.AuthDataRequest, ...grpc.CallOption) (*proto.AuthTokenResponse, error)) *mockSyncClient_SignUp_Call {
	_c.Call.Return(run)
	return _c
}

// Sync provides a mock function with given fields: ctx, in, opts
func (_m *mockSyncClient) Sync(ctx context.Context, in *proto.SyncRequest, opts ...grpc.CallOption) (*proto.SyncResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *proto.SyncResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *proto.SyncRequest, ...grpc.CallOption) (*proto.SyncResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *proto.SyncRequest, ...grpc.CallOption) *proto.SyncResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*proto.SyncResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *proto.SyncRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockSyncClient_Sync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sync'
type mockSyncClient_Sync_Call struct {
	*mock.Call
}

// Sync is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.SyncRequest
//   - opts ...grpc.CallOption
func (_e *mockSyncClient_Expecter) Sync(ctx interface{}, in interface{}, opts ...interface{}) *mockSyncClient_Sync_Call {
	return &mockSyncClient_Sync_Call{Call: _e.mock.On("Sync",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *mockSyncClient_Sync_Call) Run(run func(ctx context.Context, in *proto.SyncRequest, opts ...grpc.CallOption)) *mockSyncClient_Sync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*proto.SyncRequest), variadicArgs...)
	})
	return _c
}

func (_c *mockSyncClient_Sync_Call) Return(_a0 *proto.SyncResponse, _a1 error) *mockSyncClient_Sync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockSyncClient_Sync_Call) RunAndReturn(run func(context.Context, *proto.SyncRequest, ...grpc.CallOption) (*proto.SyncResponse, error)) *mockSyncClient_Sync_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateChest provides a mock function with given fields: ctx, in, opts
func (_m *mockSyncClient) UpdateChest(ctx context.Context, in *proto.ChestRequest, opts ...grpc.CallOption) (*proto.HistoryResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *proto.HistoryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *proto.ChestRequest, ...grpc.CallOption) (*proto.HistoryResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *proto.ChestRequest, ...grpc.CallOption) *proto.HistoryResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*proto.HistoryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *proto.ChestRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// mockSyncClient_UpdateChest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateChest'
type mockSyncClient_UpdateChest_Call struct {
	*mock.Call
}

// UpdateChest is a helper method to define mock.On call
//   - ctx context.Context
//   - in *proto.ChestRequest
//   - opts ...grpc.CallOption
func (_e *mockSyncClient_Expecter) UpdateChest(ctx interface{}, in interface{}, opts ...interface{}) *mockSyncClient_UpdateChest_Call {
	return &mockSyncClient_UpdateChest_Call{Call: _e.mock.On("UpdateChest",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *mockSyncClient_UpdateChest_Call) Run(run func(ctx context.Context, in *proto.ChestRequest, opts ...grpc.CallOption)) *mockSyncClient_UpdateChest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*proto.ChestRequest), variadicArgs...)
	})
	return _c
}

func (_c *mockSyncClient_UpdateChest_Call) Return(_a0 *proto.HistoryResponse, _a1 error) *mockSyncClient_UpdateChest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *mockSyncClient_UpdateChest_Call) RunAndReturn(run func(context.Context, *proto.ChestRequest, ...grpc.CallOption) (*proto.HistoryResponse, error)) *mockSyncClient_UpdateChest_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTnewMockSyncClient interface {
	mock.TestingT
	Cleanup(func())
}

// newMockSyncClient creates a new instance of mockSyncClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func newMockSyncClient(t mockConstructorTestingTnewMockSyncClient) *mockSyncClient {
	mock := &mockSyncClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
