# ya-goph-keeper-client

### Краткое описание работы приложения
Приложение позволяет добавлять, изменять, удалять, синхронизировать данные (пароли, данные карт памяти, файлы (бинарные данные)). Шифруя данные на клиента с помощью мастер пароля.

### Варианы работы приложения:
- Локально
- С использование сервера (синхронизация между клиентоми и сервером)

### Принцип работы
Добавление, удаление, измерение данных происходит при взаимодействии с терминалом с помощью соответсвующих команд.
Для сохраниеня данныех необходимо установать мастер пароль для хранилища. Без этого пароля данные не прочитать.
Для синхронихации с сервером, необходимо зарегистироваться или авторизовать на сервере (логин, пароль), после этого появится возможность выполнить синхронизацию.
При синхронизации будут добавлены новые, обновлены старые либо удалены текущие данные в зависимости от времени последнего действия выполненного с этими данными.

* [keeper](./doc/keeper.md) Список допустимых команд

### Приложение использует:
- приложения для работы с терминалом viper, cobra
- Sqlite3/sqlx для храниния и взаимодейтвия с информацией
- Шифрование данных aes256
- grpc для взаимодействия с сервером при синхронизации


### Шифрование
Для шифрования использется aes256.
1. Получаем мастер пароль.
2. Генерируем соль используя криптографическую случайную последовательность.
3. Используя соль и мастер пароль генерируем 32 битный ключ используя pbkdf2.
4. Шифруем данные с помощью aes256 используя полученный ключ и сохраняем в базу данных.
Соль с шага 2 генерируется каждый раз при создании новых данных и храниться вместе с данными в хранилище.
При расшифровке.
1. Берем хранящуюся с данными соль.
2. Запрашиваем мастер пароль.
3. Используя соль и мастер пароль генерируем 32 битный ключ используя pbkdf2.
4. Производим попытку расшифровки данных если соль и мастер пароль теже самые, то данные расшифруются, в противном случае нет.

### Хранение данных
Локально данные хранятся в sqlite3 зашифрованные мастер паролем за исключение имени ресурса, например имя ресура disk.yandex.ru пароль: abrakadabra в этом случае пароль будет храниться в зашифрованном виде, имя ресурса нет, мастер пароль не хрониться ни где ни локально ни на сервере, он вводится при чтении,изменении,удалении,создании данных. В случае если мастер пароль будет утерян или забыт данные восстановить не получиться!!!

Исользую две таблицы chest и history.
Chets хранит следующие данные:
```sql
id text not null, 
user_id text, -- опционально, только если данные синхронизируются с сервером.
salt blob not null, -- соль необходимая для расшифровки.
name text not null, -- определение ресурса или источника данныех. не зашифровано.
data blob not null, -- только зашифрованные данные.
data_type smallint, -- тип данных. не зашифровано.
----------

id text not null,
chest_id text not null, -- id сундука
user_id text, -- опционально, только если данные синхронизируются с сервером.
operation_type smallint not null, -- тип операции создание,изменение,удаление 
operation_time integer not null, -- время выполнения операции основное время, используется при синхронизации.
syncing_time integer, -- отметка что данное событие было синхронизировано на сервере, используется при синхронизации.
device_name text not null, -- данные об устройстве с которого была выполнена данная операция, извелекается локально.
device_ip text, -- данные об ip адере устройства с которого произошла синхронизация данных событий, извлекается при обращении к серверу, если используется локально данное поле не заполняется.

```

### Принцип работы синхронизации
Локально извлекаем все последние события(например было создание,изменение,удаление, то последним событием будет удаление) для каждого сундука, после чего полученные данные отправляем на сервер. На сервере происходит тоже самое извлекаются все последние события для каждого сундука, после чего начинается процесс сравнивания последних оперций для каждого сундука. Алгоритм сравнения слудующий: Если локальное событие выполнено позже синхронизированного события, то локально событие добавляется в результат, если обратное то в результат будет добавлено синхронизированное событие. Также если локального события нет на сервере, то оно добавляется в результат и если собтия с сервера нет в локальных оно добаляется в результат. После результат возвращается на клиент. Клиент проходит по таблице событий и запрашивает данные в случае если событие создание/изменение, и удаляет данные в случае если событие удаление. Код отвечающий за синхронизацию на клиенте находится в функции
func (c *usecases) Sync(ctx context.Context, statusOutput io.Writer) error 
